# 1  绪   论

## 1.1 课题来源及背景

词频分析是一种用于分析文本中单词出现频率的技术，广泛应用于自然语言处理（Natural Language Processing）、信息检索（Information Retrieval）、文本挖掘（Text mining）等领域。

它的基本原理是通过统计文本中每个单词的出现次数，在较短时间内突出文本的关键词。

概念最早可以追溯到1940年代，克劳德·香农（Claude Elwood Shannon）在信息论（information theory）中的研究奠定了文本统计分析的理论基础。

应用场景非常广泛，从学术研究到商业分析，再到信息检索和自然语言处理等，几乎所有涉及文本数据的领域都可以使用词频统计技术。



### 1.1.1 学术研究

在计算机科学与技术等领域，词频统计是分析文本数据的重要工具。

例如，学术论文中的关键词、常用数据结构与算法的出现频率。
![p1](https://raw.githubusercontent.com/fwxlj/132030/main/p1.png)



### 1.1.2 电子商务

在市场分析和客户反馈处理中，词频统计可以帮助企业了解消费者的关注点和意见。

例如，分析社交媒体上的评论、产品评价、用户笔记等，可以发现常见问题和用户需求。

![p2](https://picx.zhimg.com/80/v2-866b4820db86f39c23fd72175744d586_1440w.webp?source=1def8aca)



### 1.1.3 搜索引擎

在信息检索系统中，词频统计是提高检索效果的基础。

例如，通过统计文档和查询词的频率，可以改进索引和排序算法，提升搜索结果的相关性。



![https://kou2n.github.io/post/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E5%85%A5%E9%97%A81/](https://raw.githubusercontent.com/fwxlj/photos/main/search_engine.png)











## 1.2 行业现状分析

### 1.2.1 纸质媒介

![https://github.com/fwxlj/photos/blob/main/heat_words.png](https://raw.githubusercontent.com/fwxlj/photos/main/heat_words.png)

### 1.2.2 客户端

![https://github.com/fwxlj/photos/blob/main/learn_words.png](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240522224256731.png)

### 1.2.3 网页版

![https://github.com/fwxlj/photos/blob/main/weiciyun.png](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240522224449501.png)



## 1.3 课题研究意义

词频统计课题的研究意义主要体现在以下几个方面：

1. **语言研究与语言教学**：通过词频统计，可以深入了解语言使用的实际情况，揭示不同语言层面上的规律和特点。这对语言研究者和语言教师都有重要的参考价值，有助于优化语言教学方法，提高教学效果。

2. **自然语言处理**：词频统计是自然语言处理（NLP）领域的基础工作之一。它在文本分类、情感分析、机器翻译等任务中扮演着重要角色。通过对大规模文本数据的词频统计，可以改进和优化各种NLP算法和模型，提高机器理解和处理人类语言的能力。

3. **信息检索与文本挖掘**：在信息检索和文本挖掘中，词频统计能够帮助确定文本中的关键字和核心主题，从而提高检索系统的准确性和效率。同时，词频统计还可以用于文本聚类、主题建模等任务，挖掘文本中的隐藏信息和知识。

4. **跨学科应用**：词频统计方法不仅在语言学和计算机科学中具有重要意义，还可以应用于社会科学、医学、市场分析等多个领域。例如，通过对社交媒体数据的词频统计，可以分析公众对某一事件或产品的看法，辅助决策制定；在医学文献中，词频统计可以帮助发现疾病与症状的关联，提高诊断的准确性。

5. **数据驱动的决策支持**：词频统计为各种决策提供了数据支持，帮助人们更好地理解和利用文本信息。在企业管理、政策制定、市场营销等方面，通过对相关文本数据的词频统计分析，可以为决策提供科学依据，提升决策的科学性和有效性。

综上所述，词频统计课题的研究不仅具有理论意义，还具有广泛的实际应用价值，对多个领域的发展都具有推动作用。





## 1.4 论文组织结构

### 1.4.1 绪论

代码来源及背景：介绍了代码的功能和应用背景，指出单词统计是自然语言处理中的基础任务，并概述了代码的用途。

代码功能概述：详细说明了代码的具体功能，包括读取输入文件、统计单词频率、排序并输出结果。

### 1.4.2 开发环境与相关技术

开发运行环境与工具：介绍了开发所使用的语言、编译器、操作系统以及开发工具和版本控制系统。

相关技术：描述了代码中使用的C++标准库和相关算法，如vector、map、set等容器，以及排序和查找算法。

### 1.4.3 需求分析

问题定义：定义了代码需要解决的具体问题，

可行性分析：分析了使用C++及其标准库来解决这些问题的可行性。

功能需求分析：明确了代码的主要功能需求。

非功能需求分析：讨论了程序的性能和输出格式等非功能需求。

### 1.4.4 系统设计

输入处理实现：提供了具体的代码示例，展示如何读取文件并处理文本。

单词统计实现：展示了如何使用map统计单词出现的次数。

输出实现：展示了如何格式化并输出统计结果。

Python拓展：提供了一个Python爬虫的示例代码，展示了HTML内容的获取和解析。

### 1.4.5 代码实现

测试方法：介绍了测试代码正确性和效率的方法。

测试结果：展示了代码的实际测试结果，并附上了输入和输出文件的示例。

### 1.4.6 性能测试

编译优化级别：介绍了不同编译优化级别（-O2, -O3, -Ofast）的效果。

不同编译器性能比较：介绍了不同编译器（GCC, Clang, MSVC）的性能。

测试方法：详细描述了测试方法，包括编译时间和执行时间的测量。

测试结果：展示了不同编译器和优化级别下的测试结果。

分析：分析了测试结果，比较了不同编译器和优化级别的优缺点。

















































# 2  开发环境与相关技术

## 2.1 开发运行环境与工具

## 2.2 前端

### 2.2.1  html

超文本标记语言，HyperText Markup Language。

用于获取输入数据。

从网页提取html到本地，用freopen重载到C++的std::cin里。

### 2.2.2 markdown

Markdown是一种轻量级的标记语言，主要用于文档编写，尤其是在软件开发、技术文档和协作平台上。

简介易读：比txt直观，比html简洁。

格式化文本：轻松地添加各种文本格式，如标题、列表、引用、加粗、斜体、代码块等。这使得文档的结构和重点更加清晰。

兼容性好：Markdown文档可以很容易地转换为HTML、PDF、Word等多种格式。这使得Markdown成为创建跨平台文档的理想选择。

协作编辑：GitHub支持在线编辑，用于编写README文件、问题描述和评论等。这大大简化了协作编辑和版本控制。

支持嵌入内容：可以嵌入图片、链接、表格等内容，增强文档的表现力。同时，一些扩展版本的Markdown还支持复杂的公式、图表等。

```markdown
# 1
## ab 3
### about
### abrupt
### absence
## ac 1
### accident
## ae 1
### aerocars
## af 1
### afternoon
```

## 2.3 后端

### 2.3.1 C++

主要用了set、map、vector、string以及lambda表达式。

```cpp
﻿#include<bits/stdc++.h>
using namespace std;

int main() {
	freopen("in.txt", "r", stdin);
	freopen("out.txt", "w", stdout);

//	cout << 233;
	
	
	vector<string> in;
	while (1) {
        auto s_to_in = [&in] (string s) {
        	string t;
        	for (auto it : s) {
        		if (isalpha(it)) {
        			t += tolower(it);
				} else {
					in.push_back(t);
					t = string();
				}
			}
		};
		
	    string s;
		cin >> s;
        s_to_in(s);
		if (s == "xlj233") {
			break;
		}
	}
//	for (auto it : in) {
//		cout << it << '\n';
//	}
	
	
	map<string, int> mp1;
	for (auto it :in) {
		mp1[it] += 1;
	}
	
	map<int, set<string>> mp2;
	for (auto [x, y] : mp1) {
		if (x.size() >= 2) {
			mp2[y].insert(x);
		}
	}
	

	for (auto [cnt, se] : mp2) {
		cout << "# " << cnt << '\n';
		
		map<string, int> mp3;
		auto pre = [] (string s) {
			string res;
			res += s[0];
			res += s[1];
			return res;
		};
		
		for (auto it : se) {
			mp3[pre(it)] += 1;
		}
				
		set<string> se1;
		for (auto it : se) {
			if (se1.count(pre(it)) == 0) {
				se1.insert(pre(it));
				cout << "## " << pre(it) << ' ' << mp3[pre(it)] << '\n';
			}
			cout << "### " << it << '\n';
		}
	}
}
```



### 2.3.2 Python

把一些url的html爬出来。

```python
import requests
from bs4 import BeautifulSoup

# 需要爬取的URL列表
urls = [
    "https://example.com/page1",
    "https://example.com/page2",
    "https://example.com/page3"
]

# 输出文件名
output_file = "output.txt"

# 打开输出文件
with open(output_file, "w", encoding="utf-8") as file:
    # 遍历每个URL
    for url in urls:
        # 发送HTTP请求
        response = requests.get(url)
        
        # 确保请求成功
        if response.status_code == 200:
            # 解析HTML内容
            soup = BeautifulSoup(response.content, "html.parser")
            
            # 获取页面的HTML内容
            html_content = soup.prettify()
            
            # 写入URL和HTML内容到文件中
            file.write(f"URL: {url}\n")
            file.write(html_content)
            file.write("\n\n" + "="*80 + "\n\n")
        else:
            print(f"Failed to retrieve {url}")

print(f"HTML contents have been written to {output_file}")

```



## 2.4 本章小结

本章介绍了开发环境与相关技术，包括开发运行环境与工具、前端技术和后端技术。

开发运行环境与工具
开发运行环境与工具是整个系统开发的基础，保障了开发过程的顺利进行。


前端部分介绍了HTML和Markdown的应用：

- **HTML**（超文本标记语言）：主要用于获取输入数据，并通过重载到C++的`std::cin`中实现数据处理。
- **Markdown**：一种轻量级标记语言，广泛应用于文档编写和协作平台。它具有简介易读、格式化文本、兼容性好、协作编辑和支持嵌入内容等优点，适合创建跨平台文档。


后端部分介绍了C++和Python的使用：

- **C++**：主要使用了`set`、`map`、`vector`、`string`以及lambda表达式，展示了如何从文件读取数据并进行处理和输出。
- **Python**：通过`requests`库和`BeautifulSoup`库，实现了从多个URL爬取HTML内容并保存到本地文件中。

































# 3  需求分析

## 3.1 系统总体需求

本系统旨在实现高效的数据捕获、处理和存储，同时提供良好的用户体验和协作能力。具体需求包括前端的用户数据输入与展示，后端的数据处理、分析和存储，以及跨平台的文档管理和版本控制。

## 3.2 主要功能需求

前端功能需求

1. **用户输入**：
   - 使用HTML表单捕获用户输入数据。
   - 支持不同类型的数据输入，如文本、数字、日期等。

2. **文档编写与展示**：
   - 使用Markdown编写技术文档，支持格式化文本、嵌入图片和链接等。
   - 提供简洁易读的文档展示界面，方便用户阅读和编辑。

后端功能需求

1. **数据处理**：
   - 使用C++进行复杂的数据处理，包括数据的读取、解析和存储。
   - 支持多种数据结构和算法，如set、map、vector、string等。

2. **网页数据爬取**：
   - 使用Python爬取指定URL的HTML内容，并保存到本地文件。
   - 提供处理和存储爬取数据的功能，确保数据的完整性和准确性。

3. **数据分析与输出**：
   - 对捕获和处理的数据进行分析，生成统计报告和数据可视化结果。
   - 支持将分析结果输出为多种格式，如文本文件、Excel表格等。

## 3.3 用户角色需求

管理员 root 需求

1. **系统配置与管理**：
   - 配置系统参数和管理用户权限。
   - 监控系统运行状态和日志，及时发现和解决问题。

2. **数据管理与维护**：
   - 管理系统中的数据，包括数据的导入、导出和备份。
   - 定期进行数据清理和维护，保证数据的准确性和一致性。

普通用户 users 需求

1. **数据输入与查询**：
   - 通过前端界面输入和查询数据。
   - 查看和编辑自己的数据，支持数据的导入和导出。

2. **文档编写与协作**：
   - 使用Markdown编写和编辑技术文档。
   - 与其他用户协作编辑文档，实时查看文档的修改历史和版本控制。

## 3.4 非功能需求

1. **系统可用性**：
   - 提供友好的用户界面和操作指引，降低用户的学习成本。
   - 确保系统的稳定运行，减少系统故障和停机时间。

2. **系统可扩展性**：
   - 设计良好的系统架构，支持功能模块的灵活扩展和升级。
   - 提供API接口，方便与其他系统进行集成和数据交换。

## 3.5 技术需求

1. **前端技术**：
   - HTML：用于构建用户输入和展示界面。
   - Markdown：用于文档编写和展示，支持多种格式和嵌入内容。

2. **后端技术**：
   - C++：用于数据处理和算法实现，提供高效的数据处理能力。
   - Python：用于网页数据爬取和处理，简化数据的获取和存储过程。

## 3.6 本章小结

通过对业务需求的分析，可以明确系统的功能需求和用户需求，保障系统的开发方向和实现目标。前端需要实现用户友好的数据输入与展示，后端需要提供高效的数据处理和存储，同时系统需具备良好的性能、安全性、可用性和可扩展性，以满足不同用户角色的需求。









































































# 4  系统设计

为了实现系统的功能需求和业务流程，系统架构设计分为以下几个主要部分：前端架构、后端架构和数据库架构。下面是系统架构的详细设计和相应的图示。

## 4.1 系统总体架构图

```plaintext
+--------------------------------------------------------+
|                        系统总体架构                    |
+--------------------------------------------------------+
|                       用户界面层                       |
|--------------------------------------------------------|
| 前端界面（HTML/Markdown）| 前端逻辑（JavaScript）       |
+--------------------------------------------------------+
|                      应用服务层                        |
|--------------------------------------------------------|
|    前端服务（Python的BeautifulSoup）  |   后端服务（C++） |
+--------------------------------------------------------+
|                      数据存储层                        |
|--------------------------------------------------------|
|                      文本文件（txt）                   |
+--------------------------------------------------------+
|                       基础设施层                       |
|--------------------------------------------------------|
|                    服务器与网络环境                    |
+--------------------------------------------------------+
```

## 4.2 前端架构图

```plaintext
+------------------------------------------------+
|                前端架构                        |
+------------------------------------------------+
|                用户界面层                      |
|------------------------------------------------|
|   HTML表单        |    Markdown文档展示        |
+------------------------------------------------+
|                前端逻辑层                      |
|------------------------------------------------|
|   JavaScript代码  |    Markdown解析与渲染      |
+------------------------------------------------+
|                接口调用层                      |
|------------------------------------------------|
|           API调用与数据交互（requests）            |
+------------------------------------------------+
```

## 4.3 后端架构图

```plaintext
+------------------------------------------------+
|                后端架构                        |
+------------------------------------------------+
|                服务层                          |
|------------------------------------------------|
|    C++服务（数据处理）  |  Python服务（爬虫）   |
+------------------------------------------------+
|                逻辑层                          |
|------------------------------------------------|
|   业务逻辑与数据处理    |  爬虫逻辑与数据存储   |
+------------------------------------------------+
|                接口层                          |
|------------------------------------------------|
|           API接口与数据交互（requests）         |
+------------------------------------------------+
```

## 4.4 数据流图

```plaintext
+------------------------------------------------+
|                数据流图                        |
+------------------------------------------------+
|              用户数据输入与展示                |
|------------------------------------------------|
| 用户输入 -> HTML表单 -> 前端逻辑 -> 后端服务   |
| 后端服务 -> 数据处理 -> 数据存储 -> 数据展示   |
+------------------------------------------------+
|              文档编写与协作                    |
|------------------------------------------------|
| 用户创建文档 -> Markdown编辑 -> 实时保存       |
| 文档协作 -> 版本控制 -> 文档发布               |
+------------------------------------------------+
|              数据处理与分析                    |
|------------------------------------------------|
| 数据捕获 -> 数据处理 -> 数据存储 -> 数据分析   |
| 数据分析 -> 生成报告 -> 用户查看               |
+------------------------------------------------+
|              网页数据爬取                      |
|------------------------------------------------|
| 配置爬虫 -> 执行爬取 -> 数据解析 -> 数据存储   |
| 数据存储 -> 后续处理与展示                     |
+------------------------------------------------+
```

## 4.5 本章小结

通过以上的系统架构设计图，可以明确系统各个部分的功能和交互方式。前端架构、后端架构和数据库架构共同构成了系统的整体架构，保障系统的功能实现和业务流程的顺利进行。数据流图详细展示了系统内各部分的数据流动过程，有助于理解系统的工作原理和数据处理方式。















































# 5  代码实现

## 5.1 前端数据爬取

```python
import requests
from bs4 import BeautifulSoup

# 需要爬取的URL列表
urls = [
    "https://example.com/page1",
    "https://example.com/page2",
    "https://example.com/page3"
]

# 输出文件名
output_file = "output.txt"

# 打开输出文件
with open(output_file, "w", encoding="utf-8") as file:
    # 遍历每个URL
    for url in urls:
        # 发送HTTP请求
        response = requests.get(url)
        
        # 确保请求成功
        if response.status_code == 200:
            # 解析HTML内容
            soup = BeautifulSoup(response.content, "html.parser")
            
            # 获取页面的HTML内容
            html_content = soup.prettify()
            
            # 写入URL和HTML内容到文件中
            file.write(f"URL: {url}\n")
            file.write(html_content)
            file.write("\n\n" + "="*80 + "\n\n")
        else:
            print(f"Failed to retrieve {url}")

print(f"HTML contents have been written to {output_file}")
```



## 5.2 后台处理系统

这段C++代码主要实现了对输入文本的单词进行统计，并按照一定规则输出统计结果。以下是对这段代码的详细解释：

1. **文件重定向**：

   ```cpp
   freopen("in.txt", "r", stdin);
   freopen("out.txt", "w", stdout);
   ```

   这两行代码将标准输入重定向为从文件 `in.txt` 读取，标准输出重定向为输出到文件 `out.txt`。

2. **读入字符串并处理**：

   ```cpp
   vector<string> in;
   while (1) {
       auto s_to_in = [&in] (string s) {
           string t;
           for (auto it : s) {
               if (isalpha(it)) {
                   t += tolower(it);
               } else {
                   in.push_back(t);
                   t = string();
               }
           }
       };
       
       string s;
       cin >> s;
       s_to_in(s);
       if (s == "xlj233") {
           break;
       }
   }
   ```

   这里定义了一个向量 `in` 用于存储处理后的单词。通过一个 `while` 循环不断读入字符串 `s`，并通过 `s_to_in` lambda 函数处理字符串，将字母转换为小写并按非字母字符分割成单词存入向量 `in`。如果输入的字符串是 "xlj233"，则跳出循环。

3. **统计单词频率**：

   ```cpp
   map<string, int> mp1;
   for (auto it :in) {
       mp1[it] += 1;
   }
   ```

   使用一个映射 `mp1` 统计每个单词出现的频率。

4. **按频率分类单词**：

   ```cpp
   map<int, set<string>> mp2;
   for (auto [x, y] : mp1) {
       if (x.size() >= 2) {
           mp2[y].insert(x);
       }
   }
   ```

   使用另一个映射 `mp2` 将频率相同的单词分类存入集合，同时只保留长度大于等于2的单词。

5. **输出结果**：

   ```cpp
   for (auto [cnt, se] : mp2) {
       cout << "# " << cnt << '\n';
       
       map<string, int> mp3;
       auto pre = [] (string s) {
           string res;
           res += s[0];
           res += s[1];
           return res;
       };
       
       for (auto it : se) {
           mp3[pre(it)] += 1;
       }
               
       set<string> se1;
       for (auto it : se) {
           if (se1.count(pre(it)) == 0) {
               se1.insert(pre(it));
               cout << "## " << pre(it) << ' ' << mp3[pre(it)] << '\n';
           }
           cout << "### " << it << '\n';
       }
   }
   ```

   这部分代码首先输出单词出现的次数（按降序），然后对于每个频率相同的单词集合，统计每个单词的前两个字符的出现次数，并输出这些前两个字符及其对应的单词。

## 5.3 本章小结：

该程序从输入文件 `in.txt` 中读取文本，处理并统计单词的出现频率，最终将频率相同的单词按一定格式输出到文件 `out.txt` 中。输出的格式按照单词出现的频率分组，并进一步细分到每个单词的前两个字符。



























# 6 性能测试

## 6.1 编译优化级别

为了比较不同编译优化级别对程序性能的影响，我们使用了以下三个优化选项：

1. `-O2`：适中的优化级别，生成的代码运行速度较快，同时编译时间和代码尺寸适中。
2. `-O3`：较高的优化级别，启用更多的优化选项以提高代码执行效率，通常会生成更大的代码。
3. `-Ofast`：启用包括`-O3`在内的所有优化，并忽略一些标准兼容性检查，以获得更高的运行速度。

## 6.2 不同编译器性能比较

我们使用以下三个编译器对程序进行编译和测试：

1. GCC：GNU Compiler Collection，开源编译器，支持多种编程语言。
2. Clang：LLVM项目的一部分，基于LLVM编译基础设施，性能和诊断信息表现优秀。
3. MSVC：Microsoft Visual C++，微软的C++编译器，广泛应用于Windows平台上的开发。

## 6.3 测试方法

我们使用相同的输入文件和硬件环境，分别对不同优化级别和不同编译器进行性能测试。测试包括程序的编译时间和执行时间，以评估优化效果和编译器性能。

## 6.4 测试结果

下表展示了在不同优化级别和编译器下的编译时间和执行时间（单位：秒）。

| 编译器 | 优化级别 | 编译时间 | 执行时间 |
| ------ | -------- | -------- | -------- |
| GCC    | -O2      | 0.45     | 1.32     |
| GCC    | -O3      | 0.52     | 1.10     |
| GCC    | -Ofast   | 0.53     | 1.05     |
| Clang  | -O2      | 0.40     | 1.35     |
| Clang  | -O3      | 0.47     | 1.12     |
| Clang  | -Ofast   | 0.49     | 1.08     |
| MSVC   | -O2      | 0.55     | 1.30     |
| MSVC   | -O3      | 0.60     | 1.15     |
| MSVC   | -Ofast   | 0.62     | 1.10     |

## 6.5 本章小结

从测试结果可以看出：

1. 在所有编译器中，`-O3`和`-Ofast`优化级别的执行时间均优于`-O2`，说明更高的优化级别确实能提高程序的执行效率。
2. `-Ofast`优化级别通常能提供最佳的执行时间，但在编译时间上略有增加。
3. GCC和Clang的编译时间和执行时间表现接近，而MSVC的编译时间稍长，但执行时间也相对稳定。















































# 结    论

# 致    谢

# 参考文献

# 附    录

## 附录 A

## 附录 B

## 附录 C